---
title: '**secrBVN** - simulation of spatially explicit capture-recapture with bivariate normal home ranges'
author: "Murray Efford"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Spatially Explicit Capture-Recapture with Bivariate Normal Home Ranges} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc}
---

\vspace{16pt}

This small package evaluates SECR when home ranges are BVN or uniform (flat-topped) ellipses. Here we assume detection hazard is directly proportional to home range utilisation (activity). Code to use **secrBVN** for the simulations of Efford (in prep.) is provided in the [Appendix](#Appendix).

The key user-visible functions are `simpopn.bvn`, `plotpopn.bvn`, `simcapt.bvn`, `runEllipseSim` and `simsum` and `simplot`.

\vspace{12pt}

# Generating and plotting elliptical home ranges

`simpopn.bvn` is a wrapper for the **secr** function `sim.popn` that adds attributes specifying a bivariate normal home range shape, size and orientation for each individual. By default, shape and size are the same for all individuals, but the resulting popn object may be modified so they vary individually (see [Heterogeneous elliptical home ranges](#heterogeneity)).

First, load the package.
```{r startup}
library(secrBVN)
vignettefolder <- "c:/density secr 3.1/secrBVN/vignettes/"
simfolder <- "c:/density communication/noncircularity/paper/simulations/"
runall <- FALSE  # skip lengthy simulations
ncores <- 20     # for simulations
```

```{r ellipses, fig.width=8, fig.height=3}
tempgrid <- make.grid(nx = 10, ny = 10)
par(mfrow=c(2,4), mar = c(2,2,2.6,2), xpd = TRUE)
for (i in 1:4) {
    s2xy <- 25^2 * c(1/i, i)
    random.pop <- simpopn.bvn(s2xy = s2xy, core = tempgrid, buffer = 100, D = 1)
    plotpopn.bvn(random.pop, col = 'lightblue')
    mtext(side=3, line=1.5, i)
}
for (i in 1:4) {
    s2xy <- 25^2 * c(1/i, i)
    aligned.pop <- simpopn.bvn(s2xy = s2xy, core = tempgrid, buffer = 100, D = 1, theta = -1)
    plotpopn.bvn(aligned.pop, col = 'lightblue')
}
```
Fig. 1. Elliptical home ranges with varying ratio of major to minor axes as shown. Upper row oriented randomly and independently, lower row with shared random orientation ('randomly aligned').

# Simulating elliptical detection data

## Generating detection histories

Normally in **secr** we use `sim.capthist` to generate capture histories, but that is limited to circular detection functions. The function `simcapt.bvn` is a partial replacement for `sim.capthist` that models detection with a bivariate normal. Specifically, the cumulative hazard of detection is a constant times the bivariate normal probability density at the detector. The constant is $\lambda_0 2 \pi \sigma_X \sigma_Y$. The user provides a 'popn' object that includes the BVN parameter values ($\sigma_x^2, \sigma_y^2, \theta$) for each animal (row), as generated above by `simpopn.bvn`. The constant scales the BVN density so that the maximum hazard is $\lambda_0$.

The preceding paragraph describes the default behaviour of `simcapt.bvn`. If `type = uniform` is selected then a uniform (flat-topped) elliptical home range is simulated. The uniform probability of detection within the ellipse is controlled by `g0`, not `lambda0`.

## Fitting a circular detection model to BVN data

The function `runEllipseSim` is a wrapper for the preceding steps (`simpopn.bvn`, `simcapt.bvn`) that also fits a standard (circular) SECR model with `secr.fit`. The default population has fixed number of individuals within the rectangular buffered area around the detectors (`Ndist = 'fixed'`).

Here we use a $6 \times 6$ grid of binary proximity detectors with 50 metre spacing. The code in **secrBVN** does not allow for competition among detectors (secr detector type 'multi') or other other secr detector types. A density of 4/ha gives exactly 169 animals in the buffered area. The intercept parameter `g0` or `lambda0` is varied to reduce the effect of `type` on total number of captures and precision. Conditional likelihood is used for speed; the default `extractfn = derived` is compatible with both `CL = TRUE` and `CL = FALSE`. The 200-m buffer allows for the longest ranges ($\sigma_y = 50$ m).

```{r runEllipseSim, eval = runall}
nrepl <- 500
tr <- make.grid(6,6, spacing = 50, detector = 'proximity')
simrandom <- vector('list')
simrandomBVN <- vector('list')
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    details <- list(distribution = 'binomial')
    # uniform
    simrandom[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', 
        CL = TRUE, details = details) 
    # bvn
    simrandomBVN[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        CL = TRUE, details = details) 
}
save(simrandom, file = paste0(vignettefolder, 'simrandom36.2.RData'))
save(simrandomBVN, file = paste0(vignettefolder, 'simrandomBVN36.2.RData'))
```

The package function `simplot` is used to summarize the results

```{r runsumplot, fig.width = 4, fig.height = 4}
load(file = paste0(vignettefolder, 'simrandom36.2.RData'))
load(file = paste0(vignettefolder, 'simrandomBVN36.2.RData'))
par(mfrow = c(1,1), mar = c(4,4,4,4), xpd = FALSE)
output <- simplot(list(Uniform = simrandom36.2[1:4], BVN = simrandomBVN36.2[1:4]))
```

Fig. 2. Relative bias of density estimated by fitting circular SECR detection model to elliptical data, with 95\% confidence limit for simulated values. 'Uniform' home ranges were truncated at the 95\% activity contour of an equivalent bivariate normal, and detection probability was uniform inside the boundary. 'BVN' home ranges extended indefinitely in all directions.

```{r}
output
```

There is no apparent effect of range elongation itself on the bias of the estimates. Fitting a halfnormal detection function (detectfn = 0) to data from 'hard-edged' (uniform) home ranges (detectfn = 4) appears to result in negative bias on the order of --1% to --2% (Efford 2004 noted a relative bias of --1.2%, SE 0.8% for a small sample of 100 simulations fitting a model by inverse prediction in the circular case).

##Check circular using alternate method (sim.capthist)

```{r checkcircular, eval = runall}
nrepl <- 500
tr <- make.grid(6,6, spacing = 50, detector = 'proximity')
simcirc <- vector('list')
simcircBVN <- vector('list')
    sigmaX <- 25
    details <- list(distribution = 'binomial')
    # uniform
    simcirc[[1]] <- runEllipseSim (nrepl, sigmaX, sigmaY=NULL, buffer = 200, ncores = 2, 
                               traps = tr, g0 = 0.2, D = 4, type = 'uniform', CL = TRUE, 
                               details = details) 
    # bvn
    simcircBVN[[1]] <- runEllipseSim (nrepl, sigmaX, sigmaY=NULL, buffer = 200, ncores = 2, 
                               traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', CL = TRUE, 
                               details = details) 
save(simcirc, file = 'simcirc.RData')
save(simcircBVN, file = 'simcircBVN.RData')
```
```{r, results="hold"}
load(file = paste0(vignettefolder, 'simcirc.RData'))
load(file = paste0(vignettefolder, 'simcircBVN.RData'))
par(mfrow = c(1,1), mar = c(4,4,4,4), xpd = FALSE)
simsum(list(Uniform = simcirc, BVN = simcircBVN))
```

##Heterogeneous elliptical home ranges  {#heterogeneity}

`simpopn.bvn` usually generates a population with equal-sized home ranges. The size and elongation of each range may be varied by providing a function as the argument `s2xy`:
```{r heteroellipses, fig.width = 4, fig.height = 4}
tr <- make.grid(6,6, spacing = 50, detector = 'proximity')
rs2xy <- function(N, scale = 25) {   
    aspectratio <- 1 + runif(N) * 3
    cbind(scale^2 / aspectratio, scale^2 * aspectratio)
}
pop <- simpopn.bvn(s2xy = rs2xy, core = tr, buffer = 100, D = 1)
par(mfrow = c(1,1), mar = c(4,4,4,4), xpd = TRUE)
plotpopn.bvn(pop, col = 'grey')
```

Heterogeneous populations may also be simulated in `runEllipseSim` by passing a function as the argument 'sigmaX'.

```{r runhetero, eval = runall}
sims <- runEllipseSim (10, sigmaX = rs2xy, buffer = 200, ncores = 2, 
                       traps = tr, g0 = 0.2, D = 4, type = 'uniform', CL = TRUE, 
                       SECR = TRUE) 
```

# Anisotropic home ranges as a solution

In principle, we can deal with elongated ranges by replacing Euclidean distances with distances in a space transformed to render home ranges circular (Murphy et al. 2016). A simple transformation uses two parameters: $\psi_A$ for the orientation and $\psi_R$ for the degree of inflation or contraction. Thanks to Ben Augustine for pointing out the **geoR** function `coords.aniso` that lets us do this (Ribeiro and Diggle 2018).

The method does not work if the detector array is strictly linear (2-D data are required to estimate elongation). It is tested in the [Appendix](#appendix) on data from a hollow square array. In this version both transformation parameters are estimated (cf Murphy et al. 2016). This is the only place in this vignette that we attempt to *fit* elongated ranges rather than circular ranges.

The code uses a user-defined distance function that computes a Euclidean distance in the transformed space. Transformation parameters are handled in the undocumented 'miscparm' feature of 'secr'. This allows supernumerary unmodelled parameters to be included in the vector of coefficients (beta parameters) passed to the distance function and over which the likelihood is maximised. 'Unmodelled' here means that the parameter takes a single value for all animals, times and places.

```{r anisotropic, eval = TRUE, echo = TRUE}
anisodistfn <- function (xy1, xy2, mask) {
    if (missing(xy1)) return(character(0))
    xy1 <- as.matrix(xy1)
    xy2 <- as.matrix(xy2)
    miscparm <- attr(mask, 'miscparm')
    psiA <- miscparm[1]           # anisotropy angle; identity link
    psiR <- 1 + exp(miscparm[2])  # anisotropy ratio; log link
    aniso.xy1 <- geoR::coords.aniso(xy1, aniso.pars = c(psiA, psiR))
    aniso.xy2 <- geoR::coords.aniso(xy2, aniso.pars = c(psiA, psiR))
    secr::edist(aniso.xy1, aniso.xy2) # nrow(xy1) x nrow(xy2) matrix
}
```

The package **intamap** (Pebesma et al. 2010) also offers anisotropic transformation in function `rotateAnisotropicData`.

# Package limitations

This package has the limited goal of determining how range elongation affects estimates of density in simple SECR models, and these specific limitations:

1. Only binary proximity detectors are supported.
2. The spatial distribution of activity centres is assumed to be homogeneous Poisson.
3. Ellipses are specified using either 'sigmaX' and 'sigmaY' as separate arguments (`runEllipseSim`) or as a vector of the two values, squared ('s2xy' in `simpopn.bvn`). This is confusing but it's better at this point not to change.

# References

Efford, M. G. (2004) Density estimation in live-trapping studies. *Oikos* **106**, 598--610.

Efford, M. G. In prep. Non-circular home ranges and the estimation of population density.

Huggins, R. M. (1989) On the statistical analysis of capture experiments. 
*Biometrika* **76**, 133--140.

Ivan, J. S., White, G. C. and Shenk, T. M. (2013) Using simulation to compare methods for 
estimating density from capture--recapture data. 
*Ecology* **94**, 817--826.

Murphy, S. M., Cox, J. J., Augustine, B. C., Hast, J. T., Guthrie, J. M., Wright, J., McDermott, J., Maehr, S. C. and Plaxico, J. H. (2016) Characterizing recolonization by a reintroduced bear population using genetic spatial capture--recapture. *Journal of Wildlife Management* **80**, 1390--1407.

Pebesma, E., Cornford, D., Dubois, G., Heuvelink, G.B.M., Hristopoulos, D., Pilz, J., Stoehlker, U., Morin, G. and Skoien, J.O. (2010) INTAMAP: the design and implementation of an interoperable automated interpolation web service. 
*Computers & Geosciences* **37**, 343--352.

Ribeiro, P. J. Jr and Diggle, P. J. (2018). geoR: Analysis of
  Geostatistical Data. R package version 1.7-5.2.1.
  https://CRAN.R-project.org/package=geoR.

# Appendix. Code for simulations of Efford (in prep)  {#Appendix}

```{r simfolder}
simfolder <- "c:/density communication/noncircularity/paper/simulations/"
nrepl <- 500
ncores <- 20                               # for machine with at least 20 cores
runsim <- FALSE                            # change to TRUE to execute all simulations
details <- list(distribution = 'binomial') # all simulations assume fixed N
```

Functions for heterogeneous aspect ratio.
```{r heterofn}
# Uniform on 1-4
rs2xy <- function(N, scale = 25) {   
    i <- 1 + runif(N) * 3
    cbind(scale^2 /i, scale^2 * i)
}
# 2 classes 1,4
rs2xy2 <- function(N, scale = 25, prob = c(0.5,0.5)) { 
    i <- sample(c(1,4), size = N, replace = TRUE, prob = prob)
    cbind(scale^2 /i, scale^2 * i)
}
```

## Main simulations 10 x 10 grid

```{r sim1, eval = runsim}
tr <- make.grid(10,10, spacing = 50, detector = 'proximity')
simrandom100.2 <- vector('list')
names(simrandom100.2) <- c(1:4,'1-4','1,4')
simrandomBVN100.2 <- simrandom100.2
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    simrandom100.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', 
        CL = TRUE, detectfn = 'HHN', details = details)
    simrandomBVN100.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        CL = TRUE, detectfn = 'HHN', details = details)
    message ('Completed aspect ratio', i)
}
# heterogeneous aspect ratio 1,4, uniform
simrandom100.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', seed = 347, 
    CL = TRUE, detectfn = 'HHN', details = details)
# heterogeneous aspect ratio 1,4, BVN
simrandomBVN100.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', seed = 347, 
    CL = TRUE, detectfn = 'HHN', details = details)

# heterogeneous aspect ratio 1,4, uniform
simrandom100.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', 
    CL = TRUE, detectfn = 'HHN', details = details)
#heterogeneous aspect ratio 1,4, BVN
simrandomBVN100.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
    CL = TRUE, detectfn = 'HHN', details = details)

save(simrandom100.2, file = paste0(simfolder, 'simrandom100.2.RData'))
save(simrandomBVN100.2, file = paste0(simfolder, 'simrandomBVN100.2.RData'))
```

```{r sumplot1, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simrandom100.2.RData'))
load(file = paste0(simfolder, 'simrandomBVN100.2.RData'))
par(mfrow = c(1,1), mar = c(4,4,4,4), xpd = FALSE)
# select only first 4 scenarios for plotting
simplot(list(Uniform = simrandom100.2[1:4], BVN = simrandomBVN100.2[1:4]), legend = TRUE)
# tabulate all
simsum(list(Uniform = simrandom100.2, BVN = simrandomBVN100.2), compact = NULL, dec = 4)
```


```{r sumplot1a}
# compact table for paper
simsum(list(Uniform = simrandom100.2, BVN = simrandomBVN100.2))
# spatial scale parameter
output <- simsum(list(Uniform = simrandom100.2, BVN = simrandomBVN100.2), 
    component = 'pred', parm = 'sigma', compact = c("av.parmhat", "sd.parmhat"))
lapply(output, '/', 50)  # in units of detector spacing
```

## Main simulations 36-detector linear array 

```{r sim2, eval = runsim}
tr <- make.grid(36, 1, spacing = 25, detector = 'proximity')
simgridalignlin1.3 <- vector('list', 6)
names(simgridalignlin1.3) <- c(1:4,'1-4','1,4')
simgridalignlin4.3 <- simgridalignlin3.3 <- simgridalignlin2.3 <- simgridalignlin1.3 
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    # bvn parallel to traps
    simgridalignlin1.3[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn oblique to traps
    simgridalignlin2.3[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn perpendicular to traps
    simgridalignlin3.3[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn random orientation
    simgridalignlin4.3[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
        CL = TRUE, detectfn = 'HHN', details = details)
}

# bvn parallel to traps
simgridalignlin1.3[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique to traps
simgridalignlin2.3[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn perpendicular to traps
simgridalignlin3.3[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignlin4.3[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

simgridalignlin1.3[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique to traps
simgridalignlin2.3[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn perpendicular to traps
simgridalignlin3.3[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignlin4.3[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

save(simgridalignlin1.3, file = paste0(simfolder, 'simgridalignlin1.3.RData'))
save(simgridalignlin2.3, file = paste0(simfolder, 'simgridalignlin2.3.RData'))
save(simgridalignlin3.3, file = paste0(simfolder, 'simgridalignlin3.3.RData'))
save(simgridalignlin4.3, file = paste0(simfolder, 'simgridalignlin4.3.RData'))
```

```{r sumplot2, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simgridalignlin1.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin2.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin3.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin4.3.RData'))

simplot(list(Parallel = simgridalignlin1.3[1:4],
             Oblique = simgridalignlin2.3[1:4],
             Perpendicular = simgridalignlin3.3[1:4], 
             Random = simgridalignlin4.3[1:4]), 
        legend = TRUE, ylim = c(-1,3.5))
        
simsum(list(Parallel      = simgridalignlin1.3, 
             Oblique       = simgridalignlin2.3, 
             Perpendicular = simgridalignlin3.3, 
             Random        = simgridalignlin4.3))
```

## Hollow grid (linear, two directions)

```{r simhollow, eval = runsim}
tr <- make.grid(10, 10, spacing = 25, detector = 'proximity', hollow = TRUE)
simgridalignsq1.2 <- vector('list', 6)
names(simgridalignsq1.2) <- c(1:4, '1-4','1,4')
simgridalignsq3.2 <- simgridalignsq2.2 <- simgridalignsq1.2
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    details <- list(distribution = 'binomial')
    # bvn parallel to traps
    simgridalignsq1.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn oblique to traps
    simgridalignsq2.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn random orientation
    simgridalignsq3.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
        CL = TRUE, detectfn = 'HHN', details = details)
}
# heterogeneous aspect ratio 1-4
# bvn parallel to traps
simgridalignsq1.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique orientation
simgridalignsq2.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignsq3.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

# heterogeneous aspect ratio 1,4
# bvn parallel to traps
simgridalignsq1.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique orientation
simgridalignsq2.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignsq3.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

save(simgridalignsq1.2, file = paste0(simfolder, 'simgridalignsq1.2.RData'))
save(simgridalignsq2.2, file = paste0(simfolder, 'simgridalignsq2.2.RData'))
save(simgridalignsq3.2, file = paste0(simfolder, 'simgridalignsq3.2.RData'))
```

```{r sumplothollow, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simgridalignsq1.2.RData'))
load(file = paste0(simfolder, 'simgridalignsq2.2.RData'))
load(file = paste0(simfolder, 'simgridalignsq3.2.RData'))
simplot(list(Parallel = simgridalignsq1.2[1:4],
             Oblique = simgridalignsq2.2[1:4], 
             Random = simgridalignsq3.2[1:4]),
        ylim = c(-0.4,0.4), legend = TRUE)
simsum(list(Parallel = simgridalignsq1.2,
             Oblique = simgridalignsq2.2, 
             Random = simgridalignsq3.2))
```

## Linear re-check with 50-m spacing

```{r sim2, eval = runsim}
tr <- make.grid(36, 1, spacing = 50, detector = 'proximity')
simgridalignlinw1.1 <- vector('list', 6)
names(simgridalignlinw1.1) <- c(1:4,'1-4','1,4')
simgridalignlinw4.1 <- simgridalignlinw3.1 <- simgridalignlinw2.1 <- simgridalignlinw1.1 
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    
    # bvn parallel to traps
    simgridalignlinw1.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn oblique to traps
    simgridalignlinw2.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn perpendicular to traps
    simgridalignlinw3.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn random orientation
    simgridalignlinw4.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
        CL = TRUE, detectfn = 'HHN', details = details)
}

# bvn parallel to traps
simgridalignlinw1.1[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique to traps
simgridalignlinw2.1[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn perpendicular to traps
simgridalignlinw3.1[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignlinw4.1[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

simgridalignlinw1.1[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn oblique to traps
simgridalignlinw2.1[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn perpendicular to traps
simgridalignlinw3.1[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/2, 
    CL = TRUE, detectfn = 'HHN', details = details)
# bvn random orientation
simgridalignlinw4.1[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
    CL = TRUE, detectfn = 'HHN', details = details)

save(simgridalignlinw1.1, file = paste0(simfolder, 'simgridalignlinw1.1.RData'))
save(simgridalignlinw2.1, file = paste0(simfolder, 'simgridalignlinw2.1.RData'))
save(simgridalignlinw3.1, file = paste0(simfolder, 'simgridalignlinw3.1.RData'))
save(simgridalignlinw4.1, file = paste0(simfolder, 'simgridalignlinw4.1.RData'))
```

```{r}
load(file = paste0(simfolder, 'simgridalignlin1.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin2.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin3.3.RData'))
load(file = paste0(simfolder, 'simgridalignlin4.3.RData'))
load(file = paste0(simfolder, 'simgridalignlinw1.1.RData'))
load(file = paste0(simfolder, 'simgridalignlinw2.1.RData'))
load(file = paste0(simfolder, 'simgridalignlinw3.1.RData'))
load(file = paste0(simfolder, 'simgridalignlinw4.1.RData'))
par(mfrow=c(1,2))
simplot(list(Parallel      = simgridalignlin1.3[1:4],
             Oblique       = simgridalignlin2.3[1:4],
             Perpendicular = simgridalignlin3.3[1:4], 
             Random        = simgridalignlin4.3[1:4]), 
        legend = FALSE, ylim = c(-1,3.5))
simplot(list(Parallel      = simgridalignlinw1.1[1:4],
             Oblique       = simgridalignlinw2.1[1:4],
             Perpendicular = simgridalignlinw3.1[1:4], 
             Random        = simgridalignlinw4.1[1:4]), 
        legend = TRUE, ylim = c(-1,3.5))
```

## Hollow grid re-check with 50-m spacing

```{r simholloww, eval = runsim}
tr <- make.grid(10, 10, spacing = 50, detector = 'proximity', hollow = TRUE)
simgridalignsqw1.1 <- vector('list', 4)  # 'w' for wide
names(simgridalignsqw1.1) <- 1:4
simgridalignsqw3.1 <- simgridalignsqw2.1 <- simgridalignsqw1.1
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    details <- list(distribution = 'binomial')
    # bvn parallel to traps
    simgridalignsqw1.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = 0, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn oblique to traps
    simgridalignsqw2.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = pi/4, 
        CL = TRUE, detectfn = 'HHN', details = details)
    # bvn random orientation
    simgridalignsqw3.1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = NULL, 
        CL = TRUE, detectfn = 'HHN', details = details)
}
save(simgridalignsqw1.1, file = paste0(simfolder, 'simgridalignsqw1.1.RData'))
save(simgridalignsqw2.1, file = paste0(simfolder, 'simgridalignsqw2.1.RData'))
save(simgridalignsqw3.1, file = paste0(simfolder, 'simgridalignsqw3.1.RData'))
```

Compare with 25-m spacing.

```{r widehollow, eval = FALSE, fig.width = 8, fig.height = 4}
load(file = paste0(simfolder, 'simgridalignsq1.2.RData'))
load(file = paste0(simfolder, 'simgridalignsq2.2.RData'))
load(file = paste0(simfolder, 'simgridalignsq3.2.RData'))
load(file = paste0(simfolder, 'simgridalignsqw1.1.RData'))
load(file = paste0(simfolder, 'simgridalignsqw2.1.RData'))
load(file = paste0(simfolder, 'simgridalignsqw3.1.RData'))

par(mfrow=c(1,2))
simplot(list(Parallel = simgridalignsq1.2[1:4],
             Oblique = simgridalignsq2.2[1:4], 
             Random = simgridalignsq3.2[1:4]),
        ylim = c(-0.5,0.7), legend = TRUE)
simplot(list(Parallel = simgridalignsqw1.1,
             Oblique = simgridalignsqw2.1, 
             Random = simgridalignsqw3.1),
        ylim = c(-0.5,0.7), legend = TRUE)
```

## Low density 10 x 10 grid

```{r simlow, eval = runsim}
tr <- make.grid(10, 10, spacing = 50, detector = 'proximity')
simrandom100low.2 <- vector('list', 4)
simrandomBVN100low.2 <- vector('list', 4)
names(simrandom100low.2) <- 1:4
names(simrandomBVN100low.2) <- 1:4
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    simrandom100low.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, g0 = 0.2, D = 0.5, type = 'uniform', 
        CL = TRUE, detectfn = 'HHN', details = details)
    simrandomBVN100low.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 0.5, type = 'BVN', 
        CL = TRUE, detectfn = 'HHN', details = details)
}
save(simrandom100low.2, file = paste0(simfolder, 'simrandom100low.2.RData'))
save(simrandomBVN100low.2, file = paste0(simfolder, 'simrandomBVN100low.2.RData'))
```

```{r sumplotlow, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simrandom100low.2.RData'))
load(file = paste0(simfolder, 'simrandomBVN100low.2.RData'))
par(mfrow = c(1,1), mar = c(4,4,4,4), xpd = FALSE)
simplot(list(Uniform = simrandom100low.2, BVN = simrandomBVN100low.2), 
    trueval = 0.5, legend = TRUE)
simsum(list(Uniform = simrandom100low.2, BVN = simrandomBVN100low.2), 
    trueval = 0.5, compact = NULL)
```

## Small array 6 x 6 grid

```{r simsmall, eval = runsim}
tr <- make.grid(6, 6, spacing = 50, detector = 'proximity')
simrandom36.2 <- vector('list', 6)
simrandomBVN36.2 <- vector('list', 6)
names(simrandom36.2) <- c(1:4, '1-4','1,4')
names(simrandomBVN36.2) <- c(1:4, '1-4','1,4')
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    simrandom36.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', 
        CL = TRUE, detectfn = 'HHN', details = details)
    simrandomBVN36.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        CL = TRUE, detectfn = 'HHN', details = details)
    message ('Completed aspect ratio', i)
}
# heterogeneous 1-4
simrandom36.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', seed = 347, 
    CL = TRUE, detectfn = 'HHN', details = details)
simrandomBVN36.2[[5]] <- runEllipseSim (nrepl, sigmaX = rs2xy, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', seed = 347, 
    CL = TRUE, detectfn = 'HHN', details = details)

# heterogeneous 1,4
simrandom36.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', 
    CL = TRUE, detectfn = 'HHN', details = details)
simrandomBVN36.2[[6]] <- runEllipseSim (nrepl, sigmaX = rs2xy2, buffer = 200, 
    ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
    CL = TRUE, detectfn = 'HHN', details = details)
save(simrandom36.2, file = paste0(simfolder, 'simrandom36.2.RData'))
save(simrandomBVN36.2, file = paste0(simfolder, 'simrandomBVN36.2.RData'))
```

```{r sumplotsmall, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simrandom36.2.RData'))
load(file = paste0(simfolder, 'simrandomBVN36.2.RData'))
simplot(list(Uniform = simrandom36.2[1:4], BVN = simrandomBVN36.2[1:4]), legend = TRUE)
simsum(list(Uniform = simrandom36.2, BVN = simrandomBVN36.2))
```

## Common random orientation

```{r simcommon, eval = runsim}
tr <- make.grid(10, 10, spacing = 50, detector = 'proximity')
simrandom100C.2 <- vector('list', 4)
names(simrandom100C.2) <- 1:4
simrandomBVN100C.2 <- simrandom100C.2
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    simrandom100C.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, g0 = 0.2, D = 4, type = 'uniform', theta = -1,
        CL = TRUE, detectfn = 'HHN', details = details)
    simrandomBVN100C.2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', theta = -1,
        CL = TRUE, detectfn = 'HHN', details = details)
}
save(simrandom100C.2, file = paste0(simfolder, 'simrandom100C.2.RData'))
save(simrandomBVN100C.2, file = paste0(simfolder, 'simrandomBVN100C.2.RData'))
```

```{r sumplotcommon, fig.width = 5, fig.height = 4}
load(file = paste0(simfolder, 'simrandom100C.2.RData'))
load(file = paste0(simfolder, 'simrandomBVN100C.2.RData'))
simplot(list(Uniform = simrandom100C.2, BVN = simrandomBVN100C.2), legend = TRUE)
```

## Anisotropic model for data from hollow square array

```{r aniso, eval = runsim}
anisodistfn <- function (xy1, xy2, mask) {
    if (missing(xy1)) return(character(0))
    xy1 <- as.matrix(xy1)
    xy2 <- as.matrix(xy2)
    miscparm <- attr(mask, 'miscparm')
    psiA <- miscparm[1]           # anisotropy angle; identity link
    psiR <- 1 + exp(miscparm[2])  # anisotropy ratio; log link
    aniso.xy1 <- geoR::coords.aniso(xy1, aniso.pars = c(psiA, psiR))
    aniso.xy2 <- geoR::coords.aniso(xy2, aniso.pars = c(psiA, psiR))
    secr::edist(aniso.xy1, aniso.xy2) # nrow(xy1) x nrow(xy2) matrix
}
nrepl <- 500
ncores <- 20
library(geoR)
tr <- make.grid(10, 10, spacing = 25, detector = 'proximity', hollow = TRUE)
simaniso1 <- vector('list', 4); names(simaniso1) <- 1:4
simaniso4 <- simaniso3 <- simaniso2 <- simaniso1
for (i in 1:4) {
    sigmaX <- 25/i^0.5; sigmaY <- 25*i^0.5
    # parameters psiA and psiR are passed to anisodistfn in mask attribute
    details <- list(distribution = 'binomial', userdist = anisodistfn, 
             miscparm = c(psiA = 0.5, psiR = 1.5))  # miscparm initial values
    # bvn parallel to traps
    simaniso1[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores,  traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        details = details, detectfn = 'HHN', extractfn = coef, theta = 0) 
    # bvn oblique to traps
    simaniso2[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        details = details, detectfn = 'HHN', extractfn = coef, theta = pi/4) 
    # bvn random orientation
    simaniso3[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        details = details, detectfn = 'HHN', extractfn = coef, theta = NULL) 
    # bvn common random orientation
    simaniso4[[i]] <- runEllipseSim (nrepl, sigmaX, sigmaY, buffer = 200, 
        ncores = ncores, traps = tr, lambda0 = 0.4, D = 4, type = 'BVN', 
        details = details, detectfn = 'HHN', extractfn = coef, theta = -1) 
}
save(simaniso1, file = paste0(simfolder, 'simaniso1.RData'))
save(simaniso2, file = paste0(simfolder, 'simaniso2.RData'))
save(simaniso3, file = paste0(simfolder, 'simaniso3.RData'))
save(simaniso4, file = paste0(simfolder, 'simaniso4.RData'))
```

```{r sumplotaniso, echo = TRUE, eval = TRUE, fig.width = 8, fig.height = 4}
load(file = paste0(simfolder, 'simaniso1.RData'))
load(file = paste0(simfolder, 'simaniso2.RData'))
load(file = paste0(simfolder, 'simaniso3.RData'))
load(file = paste0(simfolder, 'simaniso4.RData'))
par(mfrow = c(1,2))
simplot(list(Parallel = simgridalignsq1.2[1:4],
             Oblique = simgridalignsq2.2[1:4],
             Random = simgridalignsq3.2[1:4]),
        ylim = c(-0.4,0.45), legend = TRUE)
text(-0.4, 0.5, 'a.', cex = 1.45, xpd = TRUE)
simplot(list(Parallel = simaniso1, 
             Oblique = simaniso2,
             Random = simaniso3),
        component = "pred", ylim = c(-0.4,0.45), legend = TRUE)
text(-0.4, 0.5, 'b.', cex = 1.45, xpd = TRUE)
```

[secrdesign]: https://CRAN.R-project.org/package=secrdesign/vignettes/secrdesign-vignette.pdf
